{"version":3,"sources":["../src/to-number-x.js"],"names":[],"mappings":"AAAA,OAAO,QAAP,MAAqB,WAArB;AACA,OAAO,WAAP,MAAwB,gBAAxB;AACA,OAAO,IAAP,MAAiB,QAAjB;AACA,OAAO,SAAP,MAAsB,aAAtB;AACA,OAAO,GAAP,MAAgB,OAAhB;AAEA,IAAM,WAAW,GAAG,CAApB;AACA,IAAM,UAAU,GAAG,CAAnB;AACA,IAAM,cAAc,GAAG,CAAvB;AACA,IAAM,aAAa,GAAG,2CAAtB;AAEA,IAAM,UAAU,GAAG,cAAc,CAAC,WAAlC;AACA,IAAM,SAAS,GAAG,aAAa,CAAC,KAAhC;AAEA,IAAM,WAAW,GAAG,YAApB;AACA,IAAM,iBAAiB,GAAG,WAAW,CAAC,WAAtC,C,CACA;AACA;;IACO,I,GAAQ,W,CAAR,I;;AACP,IAAM,QAAQ,GAAG,SAAS,SAAT,CAAmB,KAAnB,EAA0B;AACzC,SAAO,IAAI,CAAC,IAAL,CAAU,WAAV,EAAuB,KAAvB,CAAP;AACD,CAFD;;AAIA,IAAM,UAAU,GAAG,aAAnB;;AACA,IAAM,OAAO,GAAG,SAAS,QAAT,CAAkB,KAAlB,EAAyB;AACvC,SAAO,IAAI,CAAC,IAAL,CAAU,UAAV,EAAsB,KAAtB,CAAP;AACD,CAFD;;AAIA,IAAM,cAAc,GAAG,IAAI,iBAAJ,CAAsB,0BAAtB,EAAoD,GAApD,CAAvB;;AACA,IAAM,YAAY,GAAG,SAAS,SAAT,CAAmB,KAAnB,EAA0B;AAC7C,SAAO,IAAI,CAAC,IAAL,CAAU,cAAV,EAA0B,KAA1B,CAAP;AACD,CAFD;;AAIA,IAAM,iBAAiB,GAAG,oBAA1B;;AACA,IAAM,mBAAmB,GAAG,SAAS,oBAAT,CAA8B,KAA9B,EAAqC;AAC/D,SAAO,IAAI,CAAC,IAAL,CAAU,iBAAV,EAA6B,KAA7B,CAAP;AACD,CAFD;AAIA;;;;;;;;;AAOA,IAAM,QAAQ,GAAG,SAAS,QAAT,CAAkB,QAAlB,EAA4B;AAC3C,MAAM,KAAK,GAAG,WAAW,CAAC,QAAD,EAAW,UAAX,CAAzB;;AAEA,MAAI,QAAQ,CAAC,KAAD,CAAZ,EAAqB;AACnB,UAAM,IAAI,SAAJ,CAAc,aAAd,CAAN;AACD;;AAED,MAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,QAAI,QAAQ,CAAC,KAAD,CAAZ,EAAqB;AACnB,aAAO,QAAQ,CAAC,SAAS,CAAC,SAAS,CAAC,IAAV,CAAe,KAAf,EAAsB,cAAtB,CAAD,EAAwC,WAAxC,CAAV,CAAf;AACD;;AAED,QAAI,OAAO,CAAC,KAAD,CAAX,EAAoB;AAClB,aAAO,QAAQ,CAAC,SAAS,CAAC,SAAS,CAAC,IAAV,CAAe,KAAf,EAAsB,cAAtB,CAAD,EAAwC,UAAxC,CAAV,CAAf;AACD;;AAED,QAAI,YAAY,CAAC,KAAD,CAAZ,IAAuB,mBAAmB,CAAC,KAAD,CAA9C,EAAuD;AACrD,aAAO,GAAP;AACD;;AAED,QAAM,OAAO,GAAG,IAAI,CAAC,KAAD,CAApB;;AAEA,QAAI,OAAO,KAAK,KAAhB,EAAuB;AACrB,aAAO,QAAQ,CAAC,OAAD,CAAf;AACD;AACF;;AAED,SAAO,UAAU,CAAC,KAAD,CAAjB;AACD,CA5BD;;AA8BA,eAAe,QAAf","file":"to-number-x.esm.js","sourcesContent":["import isSymbol from 'is-symbol';\nimport toPrimitive from 'to-primitive-x';\nimport trim from 'trim-x';\nimport $parseInt from 'parse-int-x';\nimport NAN from 'nan-x';\n\nconst binaryRadix = 2;\nconst octalRadix = 8;\nconst testCharsCount = 2;\nconst ERROR_MESSAGE = 'Cannot convert a Symbol value to a number';\n\nconst castNumber = testCharsCount.constructor;\nconst pStrSlice = ERROR_MESSAGE.slice;\n\nconst binaryRegex = /^0b[01]+$/i;\nconst RegExpConstructor = binaryRegex.constructor;\n// Note that in IE 8, RegExp.prototype.test doesn't seem to exist: ie, \"test\" is\n// an own property of regexes. wtf.\nconst {test} = binaryRegex;\nconst isBinary = function _isBinary(value) {\n  return test.call(binaryRegex, value);\n};\n\nconst octalRegex = /^0o[0-7]+$/i;\nconst isOctal = function _isOctal(value) {\n  return test.call(octalRegex, value);\n};\n\nconst nonWSregex2018 = new RegExpConstructor('[\\u0085\\u180e\\u200b\\ufffe]', 'g');\nconst hasNonWS2018 = function _hasNonWS(value) {\n  return test.call(nonWSregex2018, value);\n};\n\nconst invalidHexLiteral = /^[-+]0x[0-9a-f]+$/i;\nconst isInvalidHexLiteral = function _isInvalidHexLiteral(value) {\n  return test.call(invalidHexLiteral, value);\n};\n\n/**\n * This method converts argument to a value of type Number. (ES2018).\n *\n * @param {*} [argument] - The argument to convert to a number.\n * @throws {TypeError} - If argument is a Symbol or not coercible.\n * @returns {*} The argument converted to a number.\n */\nconst toNumber = function toNumber(argument) {\n  const value = toPrimitive(argument, castNumber);\n\n  if (isSymbol(value)) {\n    throw new TypeError(ERROR_MESSAGE);\n  }\n\n  if (typeof value === 'string') {\n    if (isBinary(value)) {\n      return toNumber($parseInt(pStrSlice.call(value, testCharsCount), binaryRadix));\n    }\n\n    if (isOctal(value)) {\n      return toNumber($parseInt(pStrSlice.call(value, testCharsCount), octalRadix));\n    }\n\n    if (hasNonWS2018(value) || isInvalidHexLiteral(value)) {\n      return NAN;\n    }\n\n    const trimmed = trim(value);\n\n    if (trimmed !== value) {\n      return toNumber(trimmed);\n    }\n  }\n\n  return castNumber(value);\n};\n\nexport default toNumber;\n"]}